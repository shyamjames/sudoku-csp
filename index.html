<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sudoku CSP</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #38bdf8;
      --accent-2: #22d3ee;
      --error: #ef4444;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --border: #1f2937;
      --prefill: #1e293b;
    }
    * { box-sizing: border-box; font-family: "Segoe UI", sans-serif; }
    body {
      margin: 0; padding: 16px;
      background: radial-gradient(circle at 20% 20%, #0b1221, #0f172a 60%);
      color: var(--text); min-height: 100vh;
      display: grid; place-items: center;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      max-width: 760px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
    }
    h1 { margin: 0 0 8px; letter-spacing: 0.5px; }
    p.sub { margin: 0 0 16px; color: var(--muted); }
    .topbar { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    .pill {
      background: #0b1528;
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 10px;
      color: var(--muted);
      font-weight: 600;
    }
    #status { color: var(--muted); font-weight: 600; }
    #status.success { color: #34d399; }
    #status.error { color: var(--error); }
    .grid {
      margin: 14px 0;
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      width: min(88vw, 640px);
      border: 2px solid var(--accent);
      border-radius: 10px;
      overflow: hidden;
    }
    .cell {
      position: relative;
      border: 1px solid var(--border);
      background: #0c1426;
      aspect-ratio: 1 / 1;
    }
    .cell:nth-child(3n) { border-right: 2px solid var(--accent); }
    .cell:nth-child(9n+1) { border-left: none; }
    .cell:nth-child(n+19):nth-child(-n+27),
    .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid var(--accent); }
    input[type="text"] {
      width: 100%; height: 100%;
      background: transparent;
      border: none; outline: none;
      color: var(--text);
      font-size: clamp(14px, 2vw, 24px);
      text-align: center;
      caret-color: var(--accent-2);
    }
    input.prefill { background: var(--prefill); font-weight: 700; cursor: not-allowed; }
    input.invalid { background: rgba(239, 68, 68, 0.18); color: #fecdd3; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; }
    button {
      border: none; border-radius: 10px;
      padding: 12px 16px;
      background: var(--accent);
      color: #0b1221; font-weight: 700;
      cursor: pointer; transition: transform 120ms ease, box-shadow 120ms ease;
    }
    button.secondary { background: #1f2a44; color: var(--text); }
    button:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(56,189,248,0.25); }
    @media (max-width: 640px) {
      .grid { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Sudoku (CSP)</h1>
    <p class="sub">Fill the grid so each row, column, and 3√ó3 box contains 1‚Äì9 exactly once.</p>
    <div class="topbar">
      <div class="pill">‚è±Ô∏è Time: <span id="timer">00:00</span></div>
      <div id="status" aria-live="polite">Ready</div>
    </div>
    <div id="grid" class="grid" aria-label="Sudoku grid"></div>
    <div class="actions">
      <button id="checkBtn">Check Solution</button>
      <button id="newBtn" class="secondary">New Game</button>
      <button id="resetBtn" class="secondary">Reset</button>
      <a href="tic-tac-toe/index.html" style="text-decoration:none;">
        <button class="secondary" type="button">Play Tic Tac Toe</button>
      </a>
    </div>
  </div>

  <script>
    const puzzles = [
      {
        puzzle: "530070000600195000098000060800060003400803001700020006060000280000419005000080079"
      },
      {
        puzzle: "009000000480000120020001000000700090060030080040009000000300040057000012000000500"
      },
      {
        puzzle: "700000010020030000050100060008005040000407000030800500080002070000070020040000009"
      }
    ];

    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    const timerEl = document.getElementById("timer");
    const checkBtn = document.getElementById("checkBtn");
    const newBtn = document.getElementById("newBtn");
    const resetBtn = document.getElementById("resetBtn");

    let current, solution, startTime, tick;

    function buildGrid(puzzle) {
      gridEl.innerHTML = "";
      for (let i = 0; i < 81; i++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        const input = document.createElement("input");
        input.type = "text";
        input.maxLength = 1;
        input.dataset.index = i;
        const value = puzzle[i];
        if (value !== "0") {
          input.value = value;
          input.classList.add("prefill");
          input.readOnly = true;
        }
        input.addEventListener("input", handleInput);
        input.addEventListener("focus", () => input.select());
        cell.appendChild(input);
        gridEl.appendChild(cell);
      }
    }

    function handleInput(e) {
      const v = e.target.value.replace(/[^1-9]/g, "");
      e.target.value = v;
      validateAll();
    }

    function validateAll() {
      const cells = [...gridEl.querySelectorAll("input")];
      cells.forEach(c => c.classList.remove("invalid"));
      cells.forEach(cell => {
        const v = cell.value;
        if (!v) return;
        const idx = +cell.dataset.index;
        const r = Math.floor(idx / 9), c = idx % 9, box = Math.floor(r / 3) * 3 + Math.floor(c / 3);
        if (conflicts(cells, r, c, box, v, idx)) {
          cell.classList.add("invalid");
        }
      });
      const invalid = gridEl.querySelector(".invalid");
      if (invalid) {
        setStatus("Duplicates found in row/col/box", "error");
      } else {
        setStatus("Ready", "");
      }
    }

    function conflicts(cells, row, col, box, val, idx) {
      for (let i = 0; i < 81; i++) {
        if (i === idx) continue;
        const r = Math.floor(i / 9), c = i % 9;
        const b = Math.floor(r / 3) * 3 + Math.floor(c / 3);
        if (cells[i].value === val && (r === row || c === col || b === box)) return true;
      }
      return false;
    }

    function checkSolution() {
      const cells = [...gridEl.querySelectorAll("input")];
      if (cells.some(c => !c.value)) {
        setStatus("Fill all cells before checking.", "error");
        return;
      }
      const invalid = gridEl.querySelector(".invalid");
      if (invalid) {
        setStatus("There are duplicate numbers.", "error");
        return;
      }
      const attempt = cells.map(c => c.value).join("");
      if (attempt === solution) {
        setStatus("üéâ Correct! Sudoku solved.", "success");
        stopTimer();
      } else {
        setStatus("Incorrect solution, keep trying.", "error");
      }
    }

    function resetBoard() {
      buildGrid(current);
      setStatus("Board reset.", "");
      startTimer(true);
    }

    function newGame() {
      const pick = puzzles[Math.floor(Math.random() * puzzles.length)];
      current = pick.puzzle;
      solution = solveCSP(current);
      if (!solution) {
        setStatus("Puzzle unsolvable by CSP solver.", "error");
        return;
      }
      buildGrid(current);
      setStatus("New game started (solution derived via CSP).", "");
      startTimer(true);
    }

    function setStatus(text, type) {
      statusEl.textContent = text;
      statusEl.className = "";
      if (type) statusEl.classList.add(type === "error" ? "error" : "success");
    }

    function startTimer(reset) {
      if (reset) stopTimer();
      startTime = Date.now();
      tick = setInterval(() => {
        const diff = Date.now() - startTime;
        const m = Math.floor(diff / 60000).toString().padStart(2, "0");
        const s = Math.floor((diff % 60000) / 1000).toString().padStart(2, "0");
        timerEl.textContent = `${m}:${s}`;
      }, 500);
    }

    function stopTimer() {
      clearInterval(tick);
    }

    function solveCSP(puzzle) {
      const board = puzzle.split("").map(n => +n);

      function isValid(idx, val) {
        const row = Math.floor(idx / 9), col = idx % 9;
        // row / col check
        for (let c = 0; c < 9; c++) {
          if (board[row * 9 + c] === val && c !== col) return false;
          if (board[c * 9 + col] === val && c !== row) return false;
        }
        // box check
        const br = Math.floor(row / 3) * 3, bc = Math.floor(col / 3) * 3;
        for (let r = br; r < br + 3; r++) {
          for (let c = bc; c < bc + 3; c++) {
            const i = r * 9 + c;
            if (i !== idx && board[i] === val) return false;
          }
        }
        return true;
      }

      function mrvIndex() {
        let best = -1, bestCount = 10;
        for (let i = 0; i < 81; i++) {
          if (board[i] !== 0) continue;
          let count = 0;
          for (let v = 1; v <= 9; v++) {
            if (isValid(i, v)) count++;
          }
          if (count < bestCount) {
            bestCount = count;
            best = i;
            if (count === 1) break;
          }
        }
        return best;
      }

      function backtrack() {
        const idx = mrvIndex();
        if (idx === -1) return true; // solved
        for (let v = 1; v <= 9; v++) {
          if (!isValid(idx, v)) continue;
          board[idx] = v;
          if (backtrack()) return true;
          board[idx] = 0;
        }
        return false;
      }

      return backtrack() ? board.join("") : null;
    }

    checkBtn.addEventListener("click", checkSolution);
    newBtn.addEventListener("click", newGame);
    resetBtn.addEventListener("click", resetBoard);

    newGame(); // initialize first puzzle
  </script>
</body>
</html>
